"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resetOrder = resetOrder;

var _lexorank = require("lexorank");

var _client = _interopRequireDefault(require("part:@sanity/base/client"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var client = _client.default.withConfig({
  apiVersion: '2021-09-01'
}); // Function to wipe and re-do ordering with LexoRank
// Will at least attempt to start with the current order


function resetOrder() {
  return _resetOrder.apply(this, arguments);
}

function _resetOrder() {
  _resetOrder = _asyncToGenerator(function* () {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
    var query = "*[_type == $type]|order(@[$order] asc)._id";
    var queryParams = {
      type,
      order: _constants.ORDER_FIELD_NAME
    };
    var documents = yield client.fetch(query, queryParams);

    if (!documents.length) {
      return null;
    }

    var transaction = client.transaction();

    var aLexoRank = _lexorank.LexoRank.min();

    for (var index = 0; index < documents.length; index += 1) {
      // Generate next rank before even the first document so there's room to move!
      aLexoRank = aLexoRank.genNext().genNext();
      transaction.patch(documents[index], {
        set: {
          [_constants.ORDER_FIELD_NAME]: aLexoRank.value
        }
      });
    }

    return transaction.commit().then(update => update).catch(err => err);
  });
  return _resetOrder.apply(this, arguments);
}
//# sourceMappingURL=resetOrder.js.map