"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reorderDocuments = void 0;

var _lexorank = require("lexorank");

var _constants = require("./constants");

function lexicographicalSort(a, b) {
  if (a[_constants.ORDER_FIELD_NAME] < b[_constants.ORDER_FIELD_NAME]) {
    return -1;
  }

  if (a[_constants.ORDER_FIELD_NAME] > b[_constants.ORDER_FIELD_NAME]) {
    return 1;
  }

  return 0;
} // In lieu of actual *tests*, this is a table
// to visualise the new order which if correct, shows:
// 1. The `before` field (or start of the list)
// 2. The inserted fields, in order
// 3. The `after` document (or end of the list)
// eslint-disable-next-line no-unused-vars


function createManifest(_ref) {
  var _entities, _entities2;

  var entities = _ref.entities,
      selectedItems = _ref.selectedItems,
      isMovingUp = _ref.isMovingUp,
      curIndex = _ref.curIndex,
      nextIndex = _ref.nextIndex,
      prevIndex = _ref.prevIndex;
  var table = [{
    name: "Before",
    title: curIndex === 0 ? "<<Start of List>>" : (_entities = entities[isMovingUp ? prevIndex : curIndex]) === null || _entities === void 0 ? void 0 : _entities.title,
    order: curIndex === 0 ? "000" : entities[isMovingUp ? prevIndex : curIndex][_constants.ORDER_FIELD_NAME]
  }, ...selectedItems.map((item, itemIndex) => ({
    name: itemIndex,
    title: item === null || item === void 0 ? void 0 : item.title,
    order: item[_constants.ORDER_FIELD_NAME]
  })), {
    name: "After",
    title: curIndex === entities.length - 1 ? "<<End of List>>" : (_entities2 = entities[isMovingUp ? curIndex : nextIndex]) === null || _entities2 === void 0 ? void 0 : _entities2.title,
    order: curIndex === entities.length - 1 ? "zzz" : entities[isMovingUp ? curIndex : nextIndex][_constants.ORDER_FIELD_NAME]
  }];
  return table.sort(lexicographicalSort);
}

var reorderDocuments = _ref2 => {
  var entities = _ref2.entities,
      selectedIds = _ref2.selectedIds,
      source = _ref2.source,
      destination = _ref2.destination,
      _ref2$debug = _ref2.debug,
      debug = _ref2$debug === void 0 ? false : _ref2$debug;
  var startIndex = source.index;
  var endIndex = destination.index;
  var isMovingUp = startIndex > endIndex;
  var selectedItems = entities.filter(item => selectedIds.includes(item._id));
  var message = ["Moved", selectedItems.length === 1 ? "1 Document" : "".concat(selectedItems.length, " Documents"), isMovingUp ? "up" : "down", "from position", "".concat(startIndex + 1, " to ").concat(endIndex + 1)].join(' ');

  var _entities$reduce = entities.reduce((acc, cur, curIndex) => {
    // Selected items get spread in below, so skip them here
    if (selectedIds.includes(cur._id)) {
      return {
        all: acc.all,
        selected: acc.selected
      };
    } // Drop seleced items in


    if (curIndex === endIndex) {
      var _entities$prevIndex, _entities$prevIndex2, _entities$nextIndex, _entities$nextIndex2;

      var prevIndex = curIndex - 1;
      var prevRank = (_entities$prevIndex = entities[prevIndex]) !== null && _entities$prevIndex !== void 0 && _entities$prevIndex[_constants.ORDER_FIELD_NAME] ? _lexorank.LexoRank.parse((_entities$prevIndex2 = entities[prevIndex]) === null || _entities$prevIndex2 === void 0 ? void 0 : _entities$prevIndex2[_constants.ORDER_FIELD_NAME]) : _lexorank.LexoRank.min();

      var curRank = _lexorank.LexoRank.parse(entities[curIndex][_constants.ORDER_FIELD_NAME]);

      var nextIndex = curIndex + 1;
      var nextRank = (_entities$nextIndex = entities[nextIndex]) !== null && _entities$nextIndex !== void 0 && _entities$nextIndex[_constants.ORDER_FIELD_NAME] ? _lexorank.LexoRank.parse((_entities$nextIndex2 = entities[nextIndex]) === null || _entities$nextIndex2 === void 0 ? void 0 : _entities$nextIndex2[_constants.ORDER_FIELD_NAME]) : _lexorank.LexoRank.max();
      var betweenRank = isMovingUp ? prevRank.between(curRank) : curRank.between(nextRank); // For each selected item, assign a new orderRank between now and next

      for (var selectedIndex = 0; selectedIndex < selectedItems.length; selectedIndex += 1) {
        selectedItems[selectedIndex][_constants.ORDER_FIELD_NAME] = betweenRank.value;
        betweenRank = isMovingUp ? betweenRank.between(curRank) : betweenRank.between(nextRank);
      }

      return {
        // The `all` array gets sorted by order field later anyway
        // so that this probably isn't necessary ¯\_(ツ)_/¯
        all: isMovingUp ? [...acc.all, ...selectedItems, cur] : [...acc.all, cur, ...selectedItems],
        selected: selectedItems
      };
    }

    return {
      all: [...acc.all, cur],
      selected: acc.selected
    };
  }, {
    all: [],
    selected: []
  }),
      all = _entities$reduce.all,
      selected = _entities$reduce.selected;

  var patches = selected.map(doc => {
    return [doc._id, {
      set: {
        [_constants.ORDER_FIELD_NAME]: doc[_constants.ORDER_FIELD_NAME]
      }
    }];
  }); // Safety-check to make sure everything is in order

  var allSorted = all.sort(lexicographicalSort);
  return {
    newOrder: allSorted,
    patches,
    message
  };
};

exports.reorderDocuments = reorderDocuments;
//# sourceMappingURL=reorderDocuments.js.map